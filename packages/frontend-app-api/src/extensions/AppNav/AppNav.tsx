/*
 * Copyright 2023 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Fragment as SidebarSlice } from 'react';
import PowerIcon from '@material-ui/icons/Power';
import {
  createExtension,
  coreExtensionData,
  createExtensionInput,
  createNavItemExtension,
  createNavLogoExtension,
  createSchemaFromZod,
  useRouteRefResolver,
  AppNode,
  RouteRef,
  ExternalRouteRef,
} from '@backstage/frontend-plugin-api';
import {
  Sidebar,
  SidebarDivider,
  SidebarGroup,
  SidebarSpace as SidebarSpacer,
} from '@backstage/core-components';
import { IconComponent } from '@backstage/core-plugin-api';
import { SidebarIcon } from './SidebarIcon';
import { SidebarLogo } from './SidebarLogo';
import { SidebarItem } from './SidebarItem';
import { SidebarDrawer } from './SidebarDrawer';
import { SidebarDropdown } from './SidebarDropdown';
import { SidebarPinner } from './SidebarPinner';

/**
 * TODOS:
 * Fix group schema config type
 * add scrollable group config
 * add dropdown item subtitle prop
 * write tests and documentation
 * handle lazy loading of items
 * support feature flags
 * create a factory to override the default sidebar
 * make it possible to customize the sidebar group components
 * implement group priority ordering
 */

type GroupConfig =
  | string
  | {
      type?: 'drawer' | 'dropdown' | 'collapse';
      title: string;
      icon: string;
      spacer: boolean;
      items: GroupConfig[];
    };

export const AppNav = createExtension({
  namespace: 'app',
  name: 'nav',
  attachTo: { id: 'app/layout', input: 'nav' },
  configSchema: createSchemaFromZod(z => {
    // @ts-ignore
    const groupSchema = z.union([
      z.string(),
      z
        .object({
          title: z.string(),
          icon: z.string(),
          spacer: z.literal(true).optional(),
          type: z.enum(['drawer', 'dropdown', 'collapse']).optional(),
        })
        .extend({
          items: z.lazy(() => z.array(groupSchema).default([])),
        }),
    ]);

    return z.object({
      pinner: z.boolean().default(false),
      groups: z.array(groupSchema).default([]),
    });
  }),
  inputs: {
    items: createExtensionInput({
      target: createNavItemExtension.targetDataRef,
    }),
    logos: createExtensionInput(
      {
        elements: createNavLogoExtension.logoElementsDataRef,
      },
      {
        singleton: true,
        optional: true,
      },
    ),
  },
  output: {
    element: coreExtensionData.reactElement,
  },
  factory({ inputs, config }) {
    if (!config.groups.length) {
      return {
        element: (
          <Sidebar>
            <SidebarLogo {...inputs.logos?.output.elements} />
            {inputs.items.map(item => (
              <SidebarItem {...item.output.target} key={item.node.spec.id} />
            ))}
          </Sidebar>
        ),
      };
    }

    type GroupInput = (typeof inputs.items)[0];
    type GroupObject = {
      title: string;
      icon: string | IconComponent;
      spacer?: boolean;
      type?: 'drawer' | 'dropdown' | 'collapse';
      to?: string | RouteRef<undefined> | ExternalRouteRef<undefined>;
      items: ({ input: GroupInput } | GroupObject)[];
    };

    // Contains autogenerated items that were not grouped manually
    const pluginItems = inputs.items.reduce((reducedInputs, input) => {
      const items = Array.from(
        input.node.edges.attachments.get('items') ?? [],
      ).filter(node => !node.spec.disabled);
      if (items?.length) {
        return reducedInputs.set(input.node.spec.id, {
          ...input.output.target,
          type:
            'type' in input.output.target
              ? input.output.target.type ?? 'drawer'
              : undefined,
          items: items.reduce<GroupObject['items']>(
            (reducedItems: GroupObject['items'], node: AppNode) => {
              const target = node.instance?.getData(
                createNavItemExtension.targetDataRef,
              );
              return target
                ? [
                    ...reducedItems,
                    {
                      input: {
                        node,
                        output: { target },
                      },
                    },
                  ]
                : reducedItems;
            },
            [],
          ),
        });
      }
      return reducedInputs.set(input.node.spec.id, { input });
    }, new Map<string, GroupObject['items'][0]>());

    const groups = config.groups.reduce<GroupObject[]>(function parseGroup(
      reducedGroups: GroupObject[],
      groupConfig: GroupConfig,
    ): GroupObject[] {
      if (typeof groupConfig === 'string') {
        const item = pluginItems.get(groupConfig);
        if (!item) return reducedGroups;
        pluginItems.delete(groupConfig);
        return [
          ...reducedGroups,
          'input' in item
            ? {
                ...item.input.output.target,
                items: [item],
              }
            : item,
        ];
      }
      return [
        ...reducedGroups,
        {
          ...groupConfig,
          items: groupConfig.items.reduce<GroupObject['items']>(
            function parseItem(
              reducedItems: GroupObject['items'],
              groupItemConfig: GroupConfig,
            ): GroupObject['items'] {
              if (typeof groupItemConfig === 'string') {
                const item = pluginItems.get(groupItemConfig);
                if (!item) return reducedItems;
                pluginItems.delete(groupItemConfig);
                return [...reducedItems, item];
              }
              return parseGroup(reducedGroups, groupItemConfig);
            },
            [],
          ),
        },
      ];
    },
    []);

    // TODO: check if feature discover is enabled
    if (pluginItems.size) {
      groups.push({
        type: 'drawer',
        title: 'Plugins',
        icon: PowerIcon,
        items: Array.from(pluginItems.values()),
      });
    }

    const Component = () => {
      const resolveRouteRef = useRouteRefResolver();

      return (
        <Sidebar>
          <SidebarLogo {...inputs.logos?.output.elements} />
          {groups.map(function renderGroup(group, groupIndex) {
            const { type, title, icon, to, items, spacer } = group;
            const Icon = () => <SidebarIcon id={icon} />;
            const path =
              to && typeof to !== 'string' ? resolveRouteRef(to)?.() : to;

            const children = items.map((item, itemIndex) =>
              'input' in item ? (
                <SidebarItem
                  {...item.input.output.target}
                  key={item.input.node.spec.id}
                />
              ) : (
                renderGroup(item, itemIndex)
              ),
            );

            return (
              <SidebarSlice key={groupIndex}>
                {groupIndex ? <SidebarDivider /> : null}
                {!type ? (
                  <SidebarGroup icon={<Icon />} title={title} to={path}>
                    {children}
                  </SidebarGroup>
                ) : null}
                {type === 'drawer' ? (
                  <SidebarDrawer icon={Icon} title={title}>
                    {children}
                  </SidebarDrawer>
                ) : null}
                {type === 'dropdown' ? (
                  <SidebarDropdown icon={Icon} title={title}>
                    {children}
                  </SidebarDropdown>
                ) : null}
                {spacer ? <SidebarSpacer /> : null}
              </SidebarSlice>
            );
          })}
          {config.pinner ? <SidebarPinner /> : null}
        </Sidebar>
      );
    };

    return {
      element: <Component />,
    };
  },
});
